
name: release
on:
  workflow_run:
    workflows: ["test"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Generate token
        id: generate-token
        uses: actions/create-github-app-token@8ab05a8a84060745bdc8f0b4f6d8f403c29e06b8
        with:
          app-id: ${{ secrets.CLAUDE_APP_ID }}
          private-key: ${{ secrets.CLAUDE_PRIVATE_KEY }}

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          token: ${{ steps.generate-token.outputs.token }}
          fetch-depth: 0

      - name: Install Nix
        uses: cachix/install-nix-action@v24

      - name: Install git-cliff
        run: |
          nix profile install nixpkgs#git-cliff

      - name: Determine next version
        id: version
        shell: bash
        run: |
          set -uo pipefail

          # Find the last semver tag of the form vX.Y.Z
          LAST_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1 || true)"
          if [ -z "${LAST_TAG:-}" ]; then
            CURRENT_VERSION="0.0.0"
            RANGE="HEAD"
          else
            CURRENT_VERSION="${LAST_TAG#v}"
            RANGE="${LAST_TAG}..HEAD"
          fi

          echo "Current version: ${CURRENT_VERSION}"
          echo "Range to analyze: ${RANGE}"

          # Collect commit subjects in the chosen range
          commit_subjects="$(git log ${RANGE} --format='%s' || true)"
          commit_bodies="$(git log ${RANGE} --format='%b%n---END---' || true)"

          # Counts using Conventional Commit patterns
          FEAT_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^(feat)(\(.+\))?: ' -c || true)
          FIX_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^(fix)(\(.+\))?: ' -c || true)
          BANG_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^[a-z]+(\(.+\))?!: ' -c || true)
          BODY_BREAK_COUNT=$(printf '%s\n' "$commit_bodies" | grep -F 'BREAKING CHANGE' -c || true)
          BREAKING_COUNT=$(( BANG_COUNT + BODY_BREAK_COUNT ))

          echo "Found $FEAT_COUNT features, $FIX_COUNT fixes, $BREAKING_COUNT breaking changes"

          # Decide new version
          IFS='.' read -r MA MI PA <<< "$CURRENT_VERSION"

          if [ "$BREAKING_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="1.0.0"
            else
              NEW_VERSION="$((MA+1)).0.0"
            fi
          elif [ "$FEAT_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="0.1.0"
            else
              NEW_VERSION="$MA.$((MI+1)).0"
            fi
          elif [ "$FIX_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="0.0.1"
            else
              NEW_VERSION="$MA.$MI.$((PA+1))"
            fi
          else
            echo "No feat/fix/breaking commits since last release."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if git rev-parse -q --verify "refs/tags/v${NEW_VERSION}" >/dev/null; then
            echo "Tag v${NEW_VERSION} already exists; skipping."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_release=true" >> "$GITHUB_OUTPUT"
          echo "new_version=v${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "last_tag=${LAST_TAG}" >> "$GITHUB_OUTPUT"
          echo "range=${RANGE}" >> "$GITHUB_OUTPUT"
          echo "New version will be: v${NEW_VERSION}"

      - name: Map commits to GitHub usernames (primary + co-authors)
        id: map-commits
        if: steps.version.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          RANGE="${{ steps.version.outputs.range }}"
          OWNER="${GITHUB_REPOSITORY%%/*}"
          REPO="${GITHUB_REPOSITORY##*/}"

          # Make sure jq exists
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

          # authors.json will be { "authors": { "<sha>": [ { "login": "...", "name": "...", "email": "..." }, ... ], ... } }
          echo '{"authors":{}}' > authors.json

          # Read SHAs in the range
          mapfile -t SHAS < <(git log "${RANGE}" --pretty=format:'%H' || true)

          if [ "${#SHAS[@]}" -eq 0 ]; then
            echo "No commits in range ${RANGE}; authors.json left empty."
            echo "authors_file=authors.json" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Tunable: batch size for GraphQL queries. 50 is a pragmatic default.
          batch_size=50
          total=${#SHAS[@]}
          i=0

          while [ $i -lt $total ]; do
            batch_end=$(( i + batch_size ))
            [ $batch_end -gt $total ] && batch_end=$total

            # Build a compact GraphQL query that aliases each object call (c0, c1, ...)
            graphql='query { repository(owner:"'"$OWNER"'", name:"'"$REPO"'") {'
            idx=0
            for ((j=i;j<batch_end;j++)); do
              sha="${SHAS[j]}"
              # request the commit object and its authors connection (GitHub will include co-authors when present)
              graphql+="c${idx}: object(expression: \"${sha}\") { ... on Commit { oid authors(first: 10) { edges { node { user { login } name email } } } } } "
              idx=$((idx+1))
            done
            graphql+=' } }'

            # Execute GraphQL request (uses GH_TOKEN)
            resp="$(gh api graphql -f query="$graphql")"

            # Iterate responses and write into authors.json
            for ((k=0;k<idx;k++)); do
              oid=$(echo "$resp" | jq -r ".data.repository.c${k}.oid // empty")
              if [ -z "$oid" ]; then
                # object not found (unlikely) - skip
                continue
              fi

              # Prefer GitHub user logins when available.
              # Build array of objects { login, name?, email? } from the authors connection
              logins_json=$(echo "$resp" | jq -c ".data.repository.c${k}.authors.edges | map(.node | { login: .user.login, name: .name, email: .email }) | map(select(.login != null))")

              if [ "$logins_json" != "[]" ]; then
                # We have at least one mapped GitHub user -> store them
                jq --arg oid "$oid" --argjson arr "$logins_json" '.authors[$oid] = $arr' authors.json > authors.tmp && mv authors.tmp authors.json
                continue
              fi

              # Fallback: parse Co-authored-by trailers from the commit message (name + email)
              trailers=$(git show -s --format=%B "$oid" | grep -i '^Co-authored-by:' || true)
              if [ -n "$trailers" ]; then
                coarr='[]'
                while IFS= read -r line; do
                  # extract "Name <email@example.com>"
                  if [[ "$line" =~ ^[Cc]o-authored-by: ]]; then
                    name=$(echo "$line" | sed -E 's/^[Cc]o-authored-by:[[:space:]]*([^<]+).*/\1/' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    email=$(echo "$line" | sed -nE 's/.*<([^>]+)>.*/\1/p' || true)
                    if [ -n "$email" ]; then
                      coarr=$(jq --arg name "$name" --arg email "$email" '. + [{"name":$name,"email":$email}]' <<<"$coarr")
                    else
                      coarr=$(jq --arg name "$name" '. + [{"name":$name}]' <<<"$coarr")
                    fi
                  fi
                done <<< "$trailers"

                if [ "$coarr" != "[]" ]; then
                  jq --arg oid "$oid" --argjson arr "$coarr" '.authors[$oid] = $arr' authors.json > authors.tmp && mv authors.tmp authors.json
                  continue
                fi
              fi

              # No authors from GraphQL and no Co-authored-by trailer -> try to capture the commit author name/email
              author_name=$(git show -s --format='%aN' "$oid")
              author_email=$(git show -s --format='%aE' "$oid")
              single='[]'
              single=$(jq --arg name "$author_name" --arg email "$author_email" '. + [{"name":$name,"email":$email}]' <<<"$single")
              jq --arg oid "$oid" --argjson arr "$single" '.authors[$oid] = $arr' authors.json > authors.tmp && mv authors.tmp authors.json
            done

            i=$batch_end
          done

          # Return file path for next steps
          echo "authors_file=authors.json" >> "$GITHUB_OUTPUT"
        # end run

      - name: Generate changelog
        id: generate-changelog
        if: steps.version.outputs.should_release == 'true'
        run: |
          CHANGELOG_FILE="RELEASE_NOTES.md"
          # feed the authors.json as --context; jq -c makes a single-line JSON so the CLI arg is stable
          git-cliff --latest --config cliff.toml --strip header \
            --context "$(jq -c '.' ${{ steps.map-commits.outputs.authors_file }})" \
            > "$CHANGELOG_FILE"
          echo "changelog=$CHANGELOG_FILE" >> $GITHUB_OUTPUT

      - name: Create release
        if: steps.version.outputs.should_release == 'true'
        run: |
          gh release create ${{ steps.version.outputs.new_version }} \
            --title "Release ${{ steps.version.outputs.new_version }}" \
            --notes-file ${{ steps.generate-changelog.outputs.changelog }}
        env:
          GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}