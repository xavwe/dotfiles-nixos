name: release
on:
  workflow_run:
    workflows: ["test"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Generate token
        id: generate-token
        uses: actions/create-github-app-token@8ab05a8a84060745bdc8f0b4f6d8f403c29e06b8
        with:
          app-id: ${{ secrets.CLAUDE_APP_ID }}
          private-key: ${{ secrets.CLAUDE_PRIVATE_KEY }}

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          token: ${{ steps.generate-token.outputs.token }}
          fetch-depth: 0

      - name: Install Nix
        uses: cachix/install-nix-action@v24

      - name: Install git-cliff
        run: |
          nix profile install nixpkgs#git-cliff

      - name: Determine next version
        id: version
        shell: bash
        run: |
          set -uo pipefail

          # Find the last semver tag of the form vX.Y.Z
          LAST_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1 || true)"
          if [ -z "${LAST_TAG:-}" ]; then
            CURRENT_VERSION="0.0.0"
            RANGE="HEAD"
          else
            CURRENT_VERSION="${LAST_TAG#v}"
            RANGE="${LAST_TAG}..HEAD"
          fi

          echo "Current version: ${CURRENT_VERSION}"
          echo "Range to analyze: ${RANGE}"

          # Collect commit subjects in the chosen range (robust even if there are no matches)
          commit_subjects="$(git log ${RANGE} --format='%s' || true)"
          commit_bodies="$(git log ${RANGE} --format='%b%n---END---' || true)"

          # Counts using Conventional Commit patterns
          # feat / fix allow optional scope, and require a colon after the type
          FEAT_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^(feat)(\(.+\))?: ' -c || true)
          FIX_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^(fix)(\(.+\))?: ' -c || true)
          # Breaking changes: either "!" after type/scope OR "BREAKING CHANGE" in body
          BANG_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^[a-z]+(\(.+\))?!: ' -c || true)
          BODY_BREAK_COUNT=$(printf '%s\n' "$commit_bodies"   | grep -F 'BREAKING CHANGE' -c || true)
          BREAKING_COUNT=$(( BANG_COUNT + BODY_BREAK_COUNT ))

          echo "Found $FEAT_COUNT features, $FIX_COUNT fixes, $BREAKING_COUNT breaking changes"

          # Decide new version
          IFS='.' read -r MA MI PA <<< "$CURRENT_VERSION"

          if [ "$BREAKING_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="1.0.0"
            else
              NEW_VERSION="$((MA+1)).0.0"
            fi
          elif [ "$FEAT_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="0.1.0"
            else
              NEW_VERSION="$MA.$((MI+1)).0"
            fi
          elif [ "$FIX_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="0.0.1"
            else
              NEW_VERSION="$MA.$MI.$((PA+1))"
            fi
          else
            echo "No feat/fix/breaking commits since last release."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Prevent accidental duplicate / nonsense tags
          if git rev-parse -q --verify "refs/tags/v${NEW_VERSION}" >/dev/null; then
            echo "Tag v${NEW_VERSION} already exists; skipping."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_release=true" >> "$GITHUB_OUTPUT"
          echo "new_version=v${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "last_tag=${LAST_TAG}" >> "$GITHUB_OUTPUT"
          echo "range=${RANGE}" >> "$GITHUB_OUTPUT"
          echo "New version will be: v${NEW_VERSION}"

      - name: Generate changelog
        id: generate-changelog
        if: steps.version.outputs.should_release == 'true'
        run: |
          CHANGELOG_FILE="RELEASE_NOTES.md"
          # Only include feat and fix commits in changelog
          git-cliff --latest --config cliff.toml --strip header  > "$CHANGELOG_FILE"
          echo "changelog=$CHANGELOG_FILE" >> $GITHUB_OUTPUT

      - name: Create release
        if: steps.version.outputs.should_release == 'true'
        run: |
          gh release create ${{ steps.version.outputs.new_version }} \
            --title "Release ${{ steps.version.outputs.new_version }}" \
            --notes-file ${{ steps.generate-changelog.outputs.changelog }}
        env:
          GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}