
name: release
on:
  workflow_run:
    workflows: ["test"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Generate token
        id: generate-token
        uses: actions/create-github-app-token@8ab05a8a84060745bdc8f0b4f6d8f403c29e06b8
        with:
          app-id: ${{ secrets.CLAUDE_APP_ID }}
          private-key: ${{ secrets.CLAUDE_PRIVATE_KEY }}

      - name: Checkout repository (full history)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          token: ${{ steps.generate-token.outputs.token }}
          fetch-depth: 0

      - name: Install Nix
        uses: cachix/install-nix-action@v24

      - name: Install git-cliff via Nix
        run: |
          nix profile install nixpkgs#git-cliff

      - name: Ensure cli tools (jq, gh) are installed
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi
          if ! command -v gh >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y gh
          fi

      - name: Determine next version
        id: version
        shell: bash
        run: |
          set -uo pipefail

          # Find the last semver tag of the form vX.Y.Z
          LAST_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1 || true)"
          if [ -z "${LAST_TAG:-}" ]; then
            CURRENT_VERSION="0.0.0"
            RANGE="HEAD"
          else
            CURRENT_VERSION="${LAST_TAG#v}"
            RANGE="${LAST_TAG}..HEAD"
          fi

          echo "Current version: ${CURRENT_VERSION}"
          echo "Range to analyze: ${RANGE}"

          # Collect commit subjects & bodies in the chosen range
          commit_subjects="$(git log ${RANGE} --format='%s' || true)"
          commit_bodies="$(git log ${RANGE} --format='%b%n---END---' || true)"

          # Counts using Conventional Commit patterns
          FEAT_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^(feat)(\(.+\))?: ' -c || true)
          FIX_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^(fix)(\(.+\))?: ' -c || true)
          # Breaking changes: either "!" after type/scope OR "BREAKING CHANGE" in body
          BANG_COUNT=$(printf '%s\n' "$commit_subjects" | grep -E '^[a-z]+(\(.+\))?!: ' -c || true)
          BODY_BREAK_COUNT=$(printf '%s\n' "$commit_bodies"   | grep -F 'BREAKING CHANGE' -c || true)
          BREAKING_COUNT=$(( BANG_COUNT + BODY_BREAK_COUNT ))

          echo "Found $FEAT_COUNT features, $FIX_COUNT fixes, $BREAKING_COUNT breaking changes"

          # Decide new version
          IFS='.' read -r MA MI PA <<< "$CURRENT_VERSION"

          if [ "$BREAKING_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="1.0.0"
            else
              NEW_VERSION="$((MA+1)).0.0"
            fi
          elif [ "$FEAT_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="0.1.0"
            else
              NEW_VERSION="$MA.$((MI+1)).0"
            fi
          elif [ "$FIX_COUNT" -gt 0 ]; then
            if [ "$CURRENT_VERSION" = "0.0.0" ]; then
              NEW_VERSION="0.0.1"
            else
              NEW_VERSION="$MA.$MI.$((PA+1))"
            fi
          else
            echo "No feat/fix/breaking commits since last release."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Prevent duplicate tags
          if git rev-parse -q --verify "refs/tags/v${NEW_VERSION}" >/dev/null; then
            echo "Tag v${NEW_VERSION} already exists; skipping."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "should_release=true" >> "$GITHUB_OUTPUT"
          echo "new_version=v${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "last_tag=${LAST_TAG}" >> "$GITHUB_OUTPUT"
          echo "range=${RANGE}" >> "$GITHUB_OUTPUT"
          echo "New version will be: v${NEW_VERSION}"

      - name: Map commits to GitHub usernames (primary + co-authors), batched
        id: map-commits
        if: steps.version.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          # Tunable: increase if your repo needs it (beware GraphQL query length limits)
          BATCH_SIZE: 50
        shell: bash
        run: |
          set -euo pipefail

          RANGE="${{ steps.version.outputs.range }}"
          OWNER="${GITHUB_REPOSITORY%%/*}"
          REPO="${GITHUB_REPOSITORY##*/}"
          AUTHORS_FILE="authors.json"

          # initialize authors.json with top-level "authors" key
          echo '{"authors": {}}' > "$AUTHORS_FILE"

          # Gather SHAs in range (can be large)
          mapfile -t SHAS < <(git log "${RANGE}" --pretty=format:'%H' || true)

          if [ "${#SHAS[@]}" -eq 0 ]; then
            echo "No commits in range ${RANGE}; authors.json left empty."
            echo "authors_file=$AUTHORS_FILE" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          batch_size=${BATCH_SIZE:-50}
          total=${#SHAS[@]}
          i=0

          # Iterate in batches to avoid huge GraphQL queries
          while [ "$i" -lt "$total" ]; do
            batch_end=$(( i + batch_size ))
            [ "$batch_end" -gt "$total" ] && batch_end=$total

            # Build GraphQL query with aliases c0, c1, ...
            graphql='query { repository(owner:"'"$OWNER"'", name:"'"$REPO"'") {'
            idx=0
            for ((j=i;j<batch_end;j++)); do
              sha="${SHAS[j]}"
              # request commit oid and the authors connection (GitHub maps co-authors when it can)
              graphql+="c${idx}: object(expression: \"${sha}\") { ... on Commit { oid authors(first: 100) { edges { node { user { login } name email } } } } } "
              idx=$((idx+1))
            done
            graphql+=' } }'

            # Execute GraphQL request (uses GH_TOKEN)
            # If gh fails, continue â€” we have fallbacks per-commit
            resp="$(gh api graphql -f query="$graphql" 2>/dev/null || true)"

            # Process responses in this batch
            for ((k=0;k<idx;k++)); do
              # Extract oid (commit full sha)
              oid=$(echo "$resp" | jq -r ".data.repository.c${k}.oid // empty")

              if [ -z "$oid" ]; then
                # GraphQL did not return object; skip and fallback to commit parsing below
                continue
              fi

              # Build an array of author objects from the authors.edges returned by GraphQL
              arr=$(echo "$resp" | jq -c ".data.repository.c${k}.authors.edges // [] | map(.node | { login: (.user.login // null), name: (.name // null), email: (.email // null) })")

              # If GraphQL returned meaningful author info, persist it (prefer entries with at least one field)
              if [ "$(echo "$arr" | jq 'map(select(.login != null or .name != null or .email != null)) | length')" != "0" ]; then
                filtered=$(echo "$arr" | jq -c 'map(select(.login != null or .name != null or .email != null))')
                jq --arg oid "$oid" --argjson arr "$filtered" '.authors[$oid] = $arr' "$AUTHORS_FILE" > "${AUTHORS_FILE}.tmp" && mv "${AUTHORS_FILE}.tmp" "$AUTHORS_FILE"
                continue
              fi

              # Fallback 1: parse Co-authored-by trailers from commit message
              trailers=$(git show -s --format=%B "$oid" | grep -i '^Co-authored-by:' || true)
              if [ -n "$trailers" ]; then
                coarr='[]'
                while IFS= read -r line; do
                  if [[ "$line" =~ ^[Cc]o-authored-by: ]]; then
                    # extract "Name <email@example.com>"
                    name=$(echo "$line" | sed -E 's/^[Cc]o-authored-by:[[:space:]]*([^<]+).*/\1/' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    email=$(echo "$line" | sed -nE 's/.*<([^>]+)>.*/\1/p' || true)
                    if [ -n "$email" ]; then
                      coarr=$(jq --arg name "$name" --arg email "$email" '. + [{"name":$name,"email":$email}]' <<<"$coarr")
                    else
                      coarr=$(jq --arg name "$name" '. + [{"name":$name}]' <<<"$coarr")
                    fi
                  fi
                done <<< "$trailers"

                if [ "$(echo "$coarr" | jq 'length')" != "0" ]; then
                  jq --arg oid "$oid" --argjson arr "$coarr" '.authors[$oid] = $arr' "$AUTHORS_FILE" > "${AUTHORS_FILE}.tmp" && mv "${AUTHORS_FILE}.tmp" "$AUTHORS_FILE"
                  continue
                fi
              fi

              # Fallback 2: include the commit author name+email
              author_name=$(git show -s --format='%aN' "$oid")
              author_email=$(git show -s --format='%aE' "$oid")
              single='[]'
              single=$(jq --arg name "$author_name" --arg email "$author_email" '. + [{"name":$name,"email":$email}]' <<<"$single")
              jq --arg oid "$oid" --argjson arr "$single" '.authors[$oid] = $arr' "$AUTHORS_FILE" > "${AUTHORS_FILE}.tmp" && mv "${AUTHORS_FILE}.tmp" "$AUTHORS_FILE"
            done

            i=$batch_end
          done

          # Export path to next steps
          echo "authors_file=$AUTHORS_FILE" >> "$GITHUB_OUTPUT"

      - name: Generate changelog
        id: generate-changelog
        if: steps.version.outputs.should_release == 'true'
        run: |
          set -euo pipefail
          CHANGELOG_FILE="RELEASE_NOTES.md"

          # Pass authors.json as the template context; jq -c produces compact single-line JSON for CLI safety
          git-cliff --latest --config cliff.toml --strip header \
            --context "$(jq -c '.' ${{ steps.map-commits.outputs.authors_file }})" \
            > "$CHANGELOG_FILE"

          echo "changelog=$CHANGELOG_FILE" >> "$GITHUB_OUTPUT"

      - name: Create release
        if: steps.version.outputs.should_release == 'true'
        run: |
          gh release create ${{ steps.version.outputs.new_version }} \
            --title "Release ${{ steps.version.outputs.new_version }}" \
            --notes-file ${{ steps.generate-changelog.outputs.changelog }}
        env:
          GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}